#!/usr/bin/env python3
import random #имполртируем модуль рандом
a={}#объявляем переменную-словарь для множества A
b={}#объявляем переменную-словарь для множества B
print("Количество элементов множества А должно быть равно или меньше количеству элементов множества B")
string = input("Введите элементы множетсва A: ")#Строка для разбиения на элементы множества
for i in string:#Начало заполнения множества B
    key=i#Ключ-элемент множества
    a[key]=random.randint(0,10)/10#присваеваем элементам множества значения

string = input("Введите элементы множества B: ")#Строка для разбиения на элементы множества
for i in string:#Начало заполнения множества B
    key=i#Ключ-элемент множества
    b[key]=random.randint(0,10)/10#присваеваем элементам множества значения

print ("Проведем операции над множествами: ",a,b)#Выводим множества на экран


def obyedineniye(m1,m2):#функция объединения
    n1=m1.copy()#делаем копию, чтобы начальные значения множеств не менялись
    n2=m2.copy()#делаем копию, чтобы начальные значения множеств не менялись
    for i in n1:#перебор значений в первом множестве
        if i in n2:#если совпадает с элементом во втором, то
            if n1[i]>n2[i]:#сравниваются значения элементов, если в первом больше,то
                n2[i]=n1[i]#во втором меняется значение элемента на значений элемента из первого, то есть оставим только максимальные значения
    n1.update(n2)#дополняем первое множество элементами из второго
    print ("Результат объединения: ", n1)#выводим результат
    return n1#возвращаем результат для присваивания
ob=obyedineniye(a,b)#присваиваем


def perececheniye(m1,m2):#функция пересечения
    n1=m1.copy()#делаем копию, чтобы начальные значения множеств не менялись
    n2=m2.copy()#делаем копию, чтобы начальные значения множеств не менялись
    n2c=m2.copy()#делаем копию, чтобы в цикле удалить значения из множества через копию
    for i in n1:#перебор значений в первом множестве
        if i in n2:#если совпадает с элементом во втором, то
            if n1[i]<n2[i]:#сравниваются значения элементов, если в первом меньше,то
                n2[i]=n1[i]#во втором меняется значение элемента на значений элемента из первого, то есть оставим только минимальные значения
    for i in n2c.keys():#перебираем ключи в копии второго
        if i not in n1:#если есть такие же в первом множестве, то
            del n2[i]#удаляем
    n1.update(n2)#дополняем первое множество элементами из второго
    print ("Результат пересечения: ",n1)#выводим результат
    return n1#возвращаем результат для присваивания
per=perececheniye(a,b)#присваиваем


def raznost (m1,m2):#функция разности
    n1=m1.copy()#делаем копию, чтобы начальные значения множеств не менялись
    n2=m2.copy()#делаем копию, чтобы начальные значения множеств не менялись
    n2c=m2.copy()#делаем копию, чтобы в цикле удалить значения из множества через копию
    for i in n1:#перебор значений в первом множестве
        if i in n2:#если совпадает с элементом во втором, то
            if n1[i]>n2[i]:#сравниваются значения элементов, если в первом больше,то
                n2[i]=n1[i]-n2[i]#выполняется вычетание
            else:#иначе
                n2[i]=0#сразу присваевается ноль
    for i in n2c.keys():#перебираем ключи в копии второго
        if i not in n1:#если есть такие же в первом множестве, то
            del n2[i]#удаляем
    n1.update(n2)#дополняем первое множество элементами из второго
    n1c=n1.copy()#делаем копию, чтобы в цикле удалить нулевые значения из множества через копию
    for i in n1c.keys():#перебор значений в первом множестве
        if n1c[i]==0:#если элемент множества равен 0, то
            del n1[i]#удаляем
    if m1==a:#если из А-В, то
        print ("Результат A-B: ",n1)#выводим для них
    else:#если из B-A, то
        print ("Результат B-A: ",n1)#выводим для них
raznost(a,b)#выполняем для А-В
raznost(b,a)#выполняем для B-A


def simraznost(m1,m2):
    n1 = m1.copy()  # делаем копию, чтобы начальные значения множеств не менялись
    n1c = m1.copy()  # делаем копию, чтобы в цикле удалить нулевые значения из множества через копию
    n2 = m2.copy()  # делаем копию, чтобы начальные значения множеств не менялись
    n2c = m2.copy()  # делаем копию, чтобы в цикле удалить значения из множества через копию
    for i in n1:  # перебор значений в первом множестве
        if i in n2:  # если совпадает с элементом во втором, то
            if n1[i] > n2[i]:  # сравниваются значения элементов
                n2[i] = n1[i] - n2[i]  # выполняется вычетание из большего меньшее
            else:  # иначе
                n2[i] = n2[i]-n1[i]  # выполняется вычетание из большего меньшее
    for i in n2c.keys():  # перебираем ключи в копии второго
        if i not in n1:  # если есть такие же в первом множестве, то
            del n2[i]  # удаляем
    for i in n1c.keys():  # перебор значений в первом множестве
        if n1c[i] not in n2:  # если таких нет во втором множестве, то
            del n1[i]  # удаляем
    n1.update(n2)#дополняем первое множество элементами из второго
    print("Симметрическая разность равна: ",n1)#выводим результат
simraznost(a,b)#выполняем симметрическую разность


def dopolnenie(m1,m2):#функция дополнения
    n1 = m1.copy()  # делаем копию, чтобы начальные значения множеств не менялись
    n2 = m2.copy()  # делаем копию, чтобы начальные значения множеств не менялись
    for i in n1:#начинаем перебирать элементы первого множества
        n1[i]=1-n1[i]#находим дополнение
    for i in n2:#начинаем перебирать элементы второго множества
        n2[i]=1-n2[i]#находим дополнения
    print("Дополнения для множеств А и В равны соответственно: ",n1,n2)#выводим результаты
dopolnenie(a,b)#выполняем функцию дополнения


def podmnojestvo(m1,m2):#функция подмножества
    n1 =m1.copy()# делаем копию, чтобы начальные значения множеств не менялись
    n2=m2.copy()# делаем копию, чтобы начальные значения множеств не менялись
    log= True#начальное значение
    for i in n1:#перебираем все элементы
        if i in n2:#если такой есть во втором, то
            if n1[i]>n2[i]:#сравниваем
                log=False#ложь, если больше
                break#перестаем сравнивать
            else:#если меньше или равно
                log=True#истина
        else:#если нет такого во втором, то
            log = False#ложь
    if log==True:#если подмножество
        print ("Первое множество является подмножеством второго")
    else:#если не подмножество
        print("Первое множество НЕ является подмножеством второго")
podmnojestvo(a,b)#выполняем подмножество


print("Является ли A подмножеством объединения: ")
podmnojestvo(a,ob)#условие выше
print("Является ли B подмножеством объединения: ")
podmnojestvo(b,ob)#условие выше
print("Является ли пересечение подмножеством B: ")
podmnojestvo(per,b)#условие выше
print("Является ли пересечение подмножеством А: ")
podmnojestvo(per,a)#условие выше
input("Для выхода нажмите Enter")